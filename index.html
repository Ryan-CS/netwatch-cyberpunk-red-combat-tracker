<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Cyberpunk Combat Tracker</title>
<link href="https://em-content.zobj.net/source/apple/391/card-index_1f4c7.png" rel="icon"/>
<!-- Import Tomorrow font for all text -->
<link href="https://fonts.googleapis.com/css?family=Tomorrow:400,700&amp;display=swap" rel="stylesheet"/>
<style>
    :root {
      --yellow-color: #fcee09; 
      --red-color: #ff003c;
      --black-color: #050a0e;
      --blue-color: #00f0ff;
      --white-color: #fafafa;
    }
    body {
      font-family: 'Tomorrow', sans-serif;
      background-color: #17181f;
      color: #fee801;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow-y: auto;
    }
    h1 {
      margin: 20px;
      text-shadow: none;
    }
    h5 {
      margin: 5px;
      text-shadow: none;
    }
    .popup {
      display: none;
      position: fixed;
      z-index: 10;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
    }

    /* Explicit stacking order for popups (avoid z-index races) */
    #helpPopup { z-index: 100; }
    #damageQueuePopup,
    #damageApplyPopup { z-index: 200; }

    .popup-content {
      background-color: #17181f;
      padding: 20px;
      border: 2px solid transparent;
      color: #fee801;
      width: 50%;
      max-height: 70vh;
      overflow-y: auto;
      text-align: left;
      box-shadow: none;
      font-size: 1rem;
      border-radius: 8px;
    }
    .close-popup {
      color: #fee801;
      float: right;
      font-size: 28px;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    .close-popup:hover {
      color: #FF003C;
    }
    .table-container {
      overflow-x: auto;
      position: relative;
      width: 100%;
      margin-top: 50px;
    }
    table {
      border-collapse: collapse;
      width: 90%;
      margin: 20px;
      background-color: #17181f;
      border-radius: 8px;
    }
    tr:nth-child(4n+3),
    tr:nth-child(4n+4) {
      background-color: #27282f;
    }
    th, td {
      border: none;
      padding: 10px;
      text-align: center;
    }
    tr:nth-child(2n+1) {
      border-top: 1px solid #555;
    }
    th {
      background-color: var(--yellow-color);
      color: var(--black-color);
    }
    th.armor { display: none; }
    th.critical-injuries, td.critical-injuries {
      min-width: 160px;
      max-width: 300px;
      word-wrap: break-word;
    }
    th.initiativecol, td.initiativecol {
      min-width: 100px;
      max-width: 200px;
      word-wrap: break-word;
    }
    td.health, td.armor {
      background-color: #9a9f17;
      min-width: 7rem;
    }
    td[data-damage] {
      background-color: #36131a;
    }
    input[type="number"],
    input[type="text"] {
      text-align: center;
      font-size: 1.2rem;
      font-family: 'Tomorrow', sans-serif;
      background: var(--black-color);
      color: var(--blue-color);
      border: 1px solid rgba(84, 193, 230, 0.5);
    }
    input[type="text"] {
      width: 8rem;
    }
    input[type="number"] {
      width: 4rem;
    }
    textarea {
      background: var(--black-color);
      color: var(--blue-color);
      border: 1px solid rgba(84, 193, 230, 0.5);
      font-family: 'Tomorrow', sans-serif;
    }
    .narrow-column {
      width: 6rem;
      padding: 2px;
    }
    .narrow-column input[type="checkbox"] {
      width: 1.5rem;
      height: 1.5rem;
    }
    th.narrow-column {
      word-wrap: break-word;
      white-space: normal;
    }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
    }
    .btn {
      background-color: var(--yellow-color);
      color: var(--black-color);
      font-family: 'Tomorrow', sans-serif;
      font-size: 0.85rem;
      text-transform: uppercase;
      border: none;
      padding: 0.5em 1em;
      cursor: pointer;
      clip-path: polygon(92% 0, 100% 25%, 100% 100%, 8% 100%, 0% 75%, 0 0);
      transition: transform 0.2s ease;
      margin: 1px;
    }
    .btn:hover { transform: scale(1.05); }
    .btn:active { transform: scale(0.95); }
    .btn--secondary {
      background-color: var(--white-color);
      color: var(--black-color);
    }
    .action-button {
      background-color: var(--yellow-color);
      color: var(--black-color);
      border: none;
      padding: 0;
      cursor: pointer;
      font-size: 1rem;
      clip-path: polygon(92% 0, 100% 25%, 100% 100%, 8% 100%, 0% 75%, 0 0);
      transition: transform 0.2s ease;
      width: 4rem;
      display: inline-block;
      text-align: center;
    }
    .action-button:hover { transform: scale(1.1); }
    .action-button:active { transform: scale(0.9); }
    .apply-btn {
      width: 4rem;
      padding: 0;
      display: inline-block;
      text-align: center;
    }
    #controlButtons {
      position: sticky;
      top: 52px;
      left: 0;
      background-color: #17181f;
      padding: 10px;
      z-index: 10;
    }

    #mainFilterRow {
      position: sticky;
      top: 0;
      left: 0;
      background-color: #17181f;
      padding: 10px;
      z-index: 11;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #mainNameFilter {
      flex: 1;
      max-width: 420px;
      padding: 10px 12px;
      font-size: 1rem;
      text-align: left;
      box-sizing: border-box;
    }
    .session-container {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      text-align: left;
    }
    .session-dropdown {
      display: none;
      margin-top: 6px;
      background: #17181f;
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 6px;
      box-shadow: none;
      min-width: 160px;
    }
    .session-dropdown.open { display: block; }
    .session-dropdown .btn {
      width: 100%;
      text-align: center;
      margin: 4px 0;
    }
    .art-thumb {
      width: 80px;
      height: 80px;
      background: #0d0f15;
      object-fit: cover;
      display: block;
      margin: 0 auto 4px;
    }
    .art-box {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .art-preview-container {
      position: relative;
      width: 200px;
      height: 200px;
    }
    .art-preview {
      width: 100%;
      height: 100%;
      border: 1px solid rgba(84, 193, 230, 0.5);
      background: #0d0f15;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--blue-color);
      font-size: 0.9rem;
      overflow: hidden;
    }
    .art-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .art-empty {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--blue-color);
      font-size: 0.9rem;
      text-align: center;
      padding: 6px;
      box-sizing: border-box;
    }
    /* No custom context menu for art; rely on native browser menu */
    .injury-display {
      margin-bottom: 5px;
      display: flex;
      flex-direction: column;
    }
    .injury-tag {
      display: inline-block;
      background-color: #54c1e6;
      color: var(--black-color);
      padding: 2px 5px;
      margin-right: 5px;
      border-radius: 3px;
      clip-path: polygon(92% 0, 100% 25%, 100% 100%, 8% 100%, 0% 75%, 0 0);
      font-size: 0.9rem;
    }
    .injury-tag button {
      background: none;
      border: none;
      color: #fee801;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.6rem;
      vertical-align: middle;
    }
    .injury-add select {
      vertical-align: middle;
      font-size: 0.9rem;
      padding: 2px;
    }
    .injury-add button {
      vertical-align: middle;
      margin-left: 5px;
      font-size: 0.9rem;
      padding: 2px 5px;
    }
    .initiative-cell { position: relative; }
    .initiative-toggle-btn {
      position: absolute;
      bottom: 5px;
      left: 5px;
      width: 1rem;
      height: 1rem;
      font-weight: bold;
    }
    .drag-handle {
      display: inline-block;
      cursor: grab;
      user-select: none;
      font-size: 1.1rem;
      margin-bottom: 6px;
    }
    .drop-indicator {
      height: 4px;
      background: var(--blue-color);
      border-radius: 2px;
    }
    .form-group {
      position: relative;
      display: inline-block;
      margin: 0.2em;
    }
    .form-group input {
      width: 2.5rem;
      margin-top: 0.5rem;
      text-align: center;
      font-family: 'Tomorrow', sans-serif;
    }
    .form-group label {
      position: absolute;
      left: 0;
      top: 0;
      transform: translateY(-50%);
      font-size: 0.5rem;
      color: #fee801;
      pointer-events: none;
    }
    @media screen and (max-width: 768px) {
      table { width: 100%; font-size: 0.8rem; }
      .btn { font-size: 0.75rem; padding: 0.4em 0.8em; }
      input[type="number"], input[type="text"] { width: 3rem; font-size: 0.8rem; }
    }
  
    /* Damage modals */
    .damage-modal-header {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }
    .damage-filter {
      flex: 1;
      padding: 10px 12px;
      font-size: 1rem;
      text-align: left;
      width: 100%;
      box-sizing: border-box;
    }
    .damage-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .damage-list-btn {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 10px;
      background: #0d0f15;
      color: var(--blue-color);
      border: 1px solid rgba(84, 193, 230, 0.5);
      padding: 10px 12px;
      cursor: pointer;
      font-family: 'Tomorrow', sans-serif;
      text-align: left;
      border-radius: 8px;
      transition: transform 0.12s ease, border-color 0.12s ease;
    }
    .damage-list-btn:hover {
      border-color: var(--yellow-color);
      transform: scale(1.01);
    }
    .damage-portrait {
      width: 28px;
      height: 28px;
      object-fit: cover;
      border: 1px solid #444;
      background: #0d0f15;
      border-radius: 4px;
      flex: 0 0 auto;
    }
    .damage-portrait--placeholder {
      width: 28px;
      height: 28px;
      border: 1px solid #444;
      background: #0d0f15;
      border-radius: 4px;
      flex: 0 0 auto;
    }
    .damage-apply-title {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    .damage-review {
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(84, 193, 230, 0.5);
      border-radius: 8px;
      background: #0d0f15;
      color: var(--blue-color);
      font-size: 0.95rem;
      display: none;
    }
    .damage-mini-grid {
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 12px;
      align-items: start;
    }
    .damage-mini-card {
      border: 1px solid rgba(84, 193, 230, 0.5);
      border-radius: 8px;
      padding: 10px 12px;
      background: #0d0f15;
    }
    .damage-mini-card h3 {
      margin: 0 0 8px 0;
      font-size: 0.95rem;
      color: var(--yellow-color);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

  
    .damage-char-btn { margin-left: 18px; }
</style>
</head>
<body>
<h1>&gt;&gt;NETWATCH TRACKER V./3L4CKW4LL</h1>
<div class="session-container">
<button class="btn" id="sessionToggle">Session File</button>
<div class="session-dropdown" id="sessionDropdown">
<button class="btn" id="newSession">New Session</button>
<button class="btn" id="exportData">Save Session</button>
<button class="btn" id="importData">Load Session</button>
</div>
</div>
<!-- Help popup -->
<div aria-modal="true" class="popup" id="helpPopup" role="dialog">
<div class="popup-content">
<span aria-label="Close help" class="close-popup">√ó</span>
<h2>How to Use the Tracker</h2>
<p>This tracker auto-saves to your browser. Use the buttons below to run a session, then add rows for each character or NPC.</p>
<h3>Top Controls</h3>
<ul>
<li><strong>New Session</strong>: Clear the table and stored session.</li>
<li><strong>Add Character</strong>: Append a blank row.</li>
<li><strong>Save Session / Load Session</strong>: Export or import all rows as JSON.</li>
<li><strong>Undo / Redo</strong>: Step backward or forward through recent changes.</li>
<li><strong>Sort</strong>: Keep row 1 as pivot, sort the rest by initiative.</li>
<li><strong>TOP / NEXT / PREVIOUS</strong>: Promote highest initiative to the top, advance to next combatant, or go back.</li>
</ul>
<h3>Per-Row Fields</h3>
<ul>
<li><strong>Initiative</strong>: Enter a value or click the die to roll (with 1/10 explosions).</li>
<li><strong>Name</strong>: Character label.</li>
<li><strong>STAT</strong>: Move, Body, and Will. Body/Will auto-calc Total HP.</li>
<li><strong>Death Save</strong>: Track death saves; +1 increments.</li>
<li><strong>Magazine</strong>: Current ammo; -1 / -10 adjust quickly.</li>
<li><strong>ATK / EVA</strong>: Enter bonuses and copy a roll command to clipboard.</li>
<li><strong>HP</strong>: Current HP, Total HP (calc or override), Head SP, Body SP.</li>
<li><strong>Damage</strong>: Apply damage as Full, Half (round up SP/2), or Ignore armor; ablates SP and applies headshot/critical effects.</li>
<li><strong>Effects</strong>: Headshot, Critical, and AP toggles modify damage handling.</li>
<li><strong>Notes</strong>: Freeform notes.</li>
<li><strong>Critical Injuries</strong>: Pick from the list and add; remove with the red X.</li>
<li><strong>Actions</strong>: Clone row, save a single character to JSON, load one, or delete the row.</li>
<li><strong>Expand Toggle</strong>: Triangle in Initiative cell shows/hides the detail row.</li>
</ul>
<p>Tip: Export your session before closing the tab if you want a backup beyond local storage.</p>
</div>
</div>
<!-- Apply Damage: Queue modal -->
<div aria-label="Apply damage - select target" aria-modal="true" class="popup" id="damageQueuePopup" role="dialog">
<div class="popup-content">
<span aria-label="Close apply damage" class="close-popup" id="closeDamageQueue">√ó</span>
<h2>Apply Damage</h2>
<div class="damage-modal-header">
<input autocomplete="off" class="damage-filter" id="damageQueueFilter" placeholder="Type a name..." type="text"/>
</div>
<ul class="damage-list" id="damageQueueList"></ul>
<div style="margin-top: 12px; display: flex; justify-content: flex-end; gap: 8px;">
<button class="btn btn--secondary" id="damageQueueCloseBtn">Close</button>
</div>
</div>
</div>
<!-- Apply Damage: Target modal -->
<div aria-label="Apply damage - target details" aria-modal="true" class="popup" id="damageApplyPopup" role="dialog">
<div class="popup-content">
<span aria-label="Close apply damage" class="close-popup" id="closeDamageApply">√ó</span>
<div id="damageApplyContent"></div>
<div class="damage-review" id="damageApplyReview"></div>
</div>
</div>
<div>
<button class="btn" id="addCharacter">Add Character</button>
<button class="btn" id="undoButton">Undo</button>
<button class="btn" id="redoButton">Redo</button>
<button class="btn btn--secondary" id="helpButton">Help</button>
<button class="btn" id="playerViewButton">Player View</button>
<input accept=".json" id="fileInput" style="display: none;" type="file">
</input></div>
<div class="table-container">
<div id="mainFilterRow">
  <input autocomplete="off" id="mainNameFilter" type="text" placeholder="Filter by name... (press /)" />
</div>
<div id="controlButtons">
<button class="btn" id="topButton">TOP</button>
<button class="btn" id="nextButton">‚ó§ NEXT</button>
<button class="btn" id="previousButton">PREVIOUS ‚ó¢</button>
<button class="btn" id="sortFixedButton">Sort</button><button class="btn btn--secondary damage-char-btn" id="openDamageModalBtn">Damage Character</button>
</div>
<table>
<thead>
<tr>
<th>Initiative</th>
<th>Name</th>
<th class="toggle-column" data-column="stat">STAT</th>
<th class="toggle-column" data-column="deathSave">Death Save</th>
<th class="toggle-column" data-column="magazine">Magazine</th>
<th class="toggle-column" data-column="atk">ATK</th>
<th class="toggle-column" data-column="eva">EVA</th>
<th class="health">HP</th>
<th data-damage="">DAMAGE</th>
<th class="toggle-column" data-column="effects">Effects</th>
<th class="toggle-column" data-column="notes">Notes</th>
<th class="critical-injuries">Critical Injuries</th>
<th>Actions</th>
</tr>
</thead>
<tbody id="characterTable"></tbody>
</table>
</div>
<script>
    (() => {
      "use strict";

      const isPlayerView = new URLSearchParams(window.location.search).get("view") === "player";

      const combatTracker = {
        characters: [],
        undoStack: [],
        redoStack: [],
        tableBody: document.getElementById("characterTable"),
        // Track last change to coalesce rapid text edits
        lastChange: null,
        // UI filter for quickly finding characters by name
        nameFilter: "",

// Inside the combatTracker object, add the newSession method:
newSession: () => {
  // Optionally record state if you want undo support for clearing
  combatTracker.recordState(); 
  // Clear the character list
  combatTracker.characters = [];
  // Clear saved session from localStorage (if desired)
  localStorage.removeItem("combatTrackerSession");
  // Render the empty table
  combatTracker.renderTable();
},

        // Session management
        saveSession: () => {
          localStorage.setItem("combatTrackerSession", JSON.stringify(combatTracker.characters));
        },

        loadSession: () => {
          const sessionData = localStorage.getItem("combatTrackerSession");
          combatTracker.characters = sessionData ? JSON.parse(sessionData) : [];
          combatTracker.normalizeCharacters();
          combatTracker.renderTable();
        },

        normalizeCharacters: () => {
          combatTracker.characters.forEach((char) => {
            if (typeof char.hideFromPlayer === "undefined") {
              char.hideFromPlayer = false;
            }
            if (char.artBlob) return;
            if (char.artData && typeof char.artData === "string") {
              const blobObj = combatTracker.dataUrlToBlobObj(char.artData);
              if (blobObj) {
                char.artBlob = blobObj;
              }
              delete char.artData;
            }
          });
        },

        dataUrlToBlobObj: (dataUrl) => {
          if (!dataUrl || typeof dataUrl !== "string" || !dataUrl.startsWith("data:")) return null;
          const splitIndex = dataUrl.indexOf(",");
          if (splitIndex === -1) return null;
          const header = dataUrl.substring(5, splitIndex);
          const [typePart] = header.split(";");
          const base64 = dataUrl.substring(splitIndex + 1);
          return { type: typePart || "image/png", data: base64 };
        },

        blobObjToDataUrl: (blobObj) => {
          if (!blobObj || !blobObj.data) return "";
          return `data:${blobObj.type || "image/png"};base64,${blobObj.data}`;
        },

        recordState: () => {
          combatTracker.undoStack.push(JSON.stringify(combatTracker.characters));
          if (combatTracker.undoStack.length > 40) {
            combatTracker.undoStack.shift();
          }
          combatTracker.redoStack = [];
          combatTracker.saveSession();
        },

        recordStateCoalesced: (index, key) => {
          const coalesceKeys = ["name", "notes", "details"];
          const now = Date.now();
          if (
            coalesceKeys.includes(key) &&
            combatTracker.lastChange &&
            combatTracker.lastChange.index === index &&
            combatTracker.lastChange.key === key &&
            now - combatTracker.lastChange.time < 800
          ) {
            // Skip pushing a new snapshot to avoid flooding undo during typing
            combatTracker.lastChange.time = now;
            return;
          }
          combatTracker.lastChange = { index, key, time: now };
          combatTracker.recordState();
        },

        undo: () => {
          if (combatTracker.undoStack.length) {
            combatTracker.redoStack.push(JSON.stringify(combatTracker.characters));
            combatTracker.characters = JSON.parse(combatTracker.undoStack.pop());
            combatTracker.renderTable();
          }
        },



        redo: () => {
          if (combatTracker.redoStack.length) {
            combatTracker.undoStack.push(JSON.stringify(combatTracker.characters));
            combatTracker.characters = JSON.parse(combatTracker.redoStack.pop());
            combatTracker.renderTable();
          }
        },


        // Character Manipulation
        addCharacter: () => {
          combatTracker.recordState();
          combatTracker.characters.push({
            initiative: "",
            name: "",
            move: "",
            body: "",
            will: "",
            deathSave: 0,
            magazine: 0,
            atk: "",
            eva: "",
            hp: "",
            total: 10,
            spHead: "",
            spBody: "",
            notes: "",
            details: "",
            artBlob: null,
            criticalInjuries: [],
            headshot: false,
            critical: false,
            armorPiercing: false,
            expanded: false,
            manualOverride: undefined,
            hideFromPlayer: false
          });
          combatTracker.renderTable();
        },

        updateCharacter: (index, key, value) => {
          if (`${combatTracker.characters[index][key]}` === `${value}`) return;
          combatTracker.recordStateCoalesced(index, key);
          combatTracker.characters[index][key] = value;
          if (key === 'body' || key === 'will') {
            const bodyVal = parseInt(combatTracker.characters[index].body) || 0;
            const willVal = parseInt(combatTracker.characters[index].will) || 0;
            combatTracker.characters[index].total = (Math.ceil((bodyVal + willVal) / 2) * 5) + 10;
          }
          combatTracker.renderTable();
        },

        updateCharacterCheckbox: (index, key, value) => {
          if (combatTracker.characters[index][key] === value) return;
          combatTracker.recordState();
          combatTracker.characters[index][key] = value;
          combatTracker.renderTable();
        },

        setCharacterArt: (index, dataUrl) => {
          combatTracker.recordState();
          const blobObj = combatTracker.dataUrlToBlobObj(dataUrl);
          if (!blobObj) return;
          combatTracker.characters[index].artBlob = blobObj;
          combatTracker.renderTable();
        },

        handleArtFile: (event, index) => {
          const file = event.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            combatTracker.setCharacterArt(index, e.target.result);
          };
          reader.readAsDataURL(file);
          event.target.value = "";
        },

        triggerArtUpload: (event, index) => {
          event?.stopPropagation();
          const input = document.getElementById(`artFile-${index}`);
          input?.click();
        },

        handleArtPaste: (event, index) => {
          const items = event.clipboardData?.items;
          if (!items || !items.length) return;
          const imageItem = Array.from(items).find((item) => item.type && item.type.startsWith("image/"));
          if (!imageItem) return;
          event.preventDefault();
          const file = imageItem.getAsFile();
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            combatTracker.setCharacterArt(index, e.target.result);
          };
          reader.readAsDataURL(file);
        },

        pasteArtFromClipboard: async (index) => {
          const focusTarget = document.getElementById(`artPreview-${index}`);
          const fallback = () => {
            focusTarget?.focus();
            alert("Clipboard image read not supported here. Click the art box and press Ctrl/Cmd+V to paste.");
          };
          if (!navigator.clipboard || !navigator.clipboard.read) {
            fallback();
            return;
          }
          try {
            const items = await navigator.clipboard.read();
            const imageItem = items.find((i) => i.types.some((t) => t.startsWith("image/")));
            if (!imageItem) {
              fallback();
              return;
            }
            const type = imageItem.types.find((t) => t.startsWith("image/"));
            const blob = await imageItem.getType(type);
            const reader = new FileReader();
            reader.onload = (e) => combatTracker.setCharacterArt(index, e.target.result);
            reader.readAsDataURL(blob);
          } catch (err) {
            console.error("Clipboard read failed", err);
            fallback();
          }
        },


        // Dice Rolls & Damage
        rollInitiative: (index) => {
          combatTracker.recordState();
          let current = parseInt(combatTracker.characters[index].initiative) || 0;
          const roll = Math.floor(Math.random() * 10) + 1;
          if (roll === 1) {
            current += 1 - (Math.floor(Math.random() * 10) + 1);
          } else if (roll === 10) {
            current += 10 + (Math.floor(Math.random() * 10) + 1);
          } else {
            current += roll;
          }
          combatTracker.characters[index].initiative = current;
          combatTracker.renderTable();
        },

        confirmDamage: (index, mode) => {
          combatTracker.recordState();
          const damageInput = document.getElementById(`damage-${index}`).value;
          const damage = parseInt(damageInput) || 0;
          let sp = combatTracker.characters[index].spBody;
          const { headshot, critical, armorPiercing } = combatTracker.characters[index];
          if (headshot) {
            sp = combatTracker.characters[index].spHead;
          }
          const spEffective = mode === 'ignore' ? 0 : (mode === 'half' ? Math.ceil(sp / 2) : sp);
          const penetration = damage > spEffective;
          const remainingDamage = penetration ? damage - spEffective : 0;
          if (mode !== 'ignore' && penetration) {
            const ablateValue = armorPiercing ? 2 : 1;
            if (headshot) {
              combatTracker.characters[index].spHead = Math.max(0, sp - ablateValue);
            } else {
              combatTracker.characters[index].spBody = Math.max(0, sp - ablateValue);
            }
          }
          combatTracker.characters[index].hp -= headshot ? remainingDamage * 2 : remainingDamage;
          if (critical) {
            combatTracker.characters[index].hp -= 5;
          }
          document.getElementById(`damage-${index}`).value = "";
          combatTracker.renderTable();
        },

        incrementDeathSave: (index) => {
          combatTracker.recordState();
          combatTracker.characters[index].deathSave = (parseInt(combatTracker.characters[index].deathSave) || 0) + 1;
          combatTracker.renderTable();
        },

        decrementMagazine: (index, decrementBy = 1) => {
          combatTracker.recordState();
          combatTracker.characters[index].magazine = Math.max(0, parseInt(combatTracker.characters[index].magazine) - decrementBy);
          combatTracker.renderTable();
        },

        deleteCharacter: (index) => {
          combatTracker.recordState();
          combatTracker.characters.splice(index, 1);
          combatTracker.renderTable();
        },

        addCriticalInjury: (index) => {
          combatTracker.recordState();
          const selectElem = document.getElementById(`criticalSelect-${index}`);
          const selectedInjury = selectElem.value;
          if (!combatTracker.characters[index].criticalInjuries) {
            combatTracker.characters[index].criticalInjuries = [];
          }
          combatTracker.characters[index].criticalInjuries.push(selectedInjury);
          combatTracker.renderTable();
        },

        removeCriticalInjury: (charIndex, injuryIndex) => {
          combatTracker.recordState();
          combatTracker.characters[charIndex].criticalInjuries.splice(injuryIndex, 1);
          combatTracker.renderTable();
        },

		copyCharacter: (index) => {
		  combatTracker.recordState();
		  // Deep clone the entire character object
		  const copiedChar = JSON.parse(JSON.stringify(combatTracker.characters[index]));
		  combatTracker.characters.push(copiedChar);
		  combatTracker.renderTable();
		},

        saveCharacter: (index) => {
          const charData = JSON.stringify(combatTracker.characters[index], null, 2);
          const blob = new Blob([charData], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${combatTracker.characters[index].name || "character"}.json`;
          a.click();
          URL.revokeObjectURL(url);
        },

        loadCharacter: () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "application/json";
          input.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const importedChar = JSON.parse(e.target.result);
                  combatTracker.recordState();
                  combatTracker.characters.push(importedChar);
                  combatTracker.normalizeCharacters();
                  combatTracker.renderTable();
                } catch (error) {
                  alert("Error loading character file: " + error.message);
                }
              };
              reader.readAsText(file);
            }
          });
          input.click();
        },

        // Attack, Evasion & Clipboard
        rollAttack: (index) => {
          const atkValue = combatTracker.characters[index].atk || 0;
          const command = `!r 1d10+${atkValue} Attack`;
          combatTracker.copyTextToClipboard(command);
        },

        rollEvasion: (index) => {
          const evaValue = combatTracker.characters[index].eva || 0;
          const command = `!r 1d10+${evaValue} Evasion`;
          combatTracker.copyTextToClipboard(command);
        },

        copyTextToClipboard: (text) => {
          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(text).catch(() => combatTracker.fallbackCopyTextToClipboard(text));
          } else {
            combatTracker.fallbackCopyTextToClipboard(text);
          }
        },

        fallbackCopyTextToClipboard: (text) => {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
          } catch (err) {
            console.error("Fallback: Unable to copy", err);
          }
          document.body.removeChild(textarea);
        },

        // Details Toggle and Sorting
        toggleDetails: (index) => {
          combatTracker.characters[index].expanded = !combatTracker.characters[index].expanded;
          combatTracker.characters[index].manualOverride = combatTracker.characters[index].expanded;
          combatTracker.renderTable();
        },

        sortWithRow1Fixed: () => {
          if (!combatTracker.characters.length) return;
          combatTracker.recordState();
          const pivot = parseFloat(combatTracker.characters[0].initiative) || 0;
          const row1 = combatTracker.characters[0];
          const rest = combatTracker.characters.slice(1);
          const groupA = rest.filter(c => (parseFloat(c.initiative) || 0) <= pivot)
                             .sort((a, b) => (parseFloat(b.initiative) || 0) - (parseFloat(a.initiative) || 0));
          const groupB = rest.filter(c => (parseFloat(c.initiative) || 0) > pivot)
                             .sort((a, b) => (parseFloat(b.initiative) || 0) - (parseFloat(a.initiative) || 0));
          combatTracker.characters = [row1, ...groupA, ...groupB];
          combatTracker.renderTable();
        },

        topButton: () => {
          if (!combatTracker.characters.length) return;
          combatTracker.recordState();
          let maxIndex = 0;
          let maxInit = parseFloat(combatTracker.characters[0].initiative) || 0;
          for (let i = 1; i < combatTracker.characters.length; i++) {
            const init = parseFloat(combatTracker.characters[i].initiative) || 0;
            if (init > maxInit) {
              maxInit = init;
              maxIndex = i;
            }
          }
          const topChar = combatTracker.characters.splice(maxIndex, 1)[0];
          combatTracker.characters.sort((a, b) => (parseFloat(b.initiative) || 0) - (parseFloat(a.initiative) || 0));
          combatTracker.characters.unshift(topChar);
          combatTracker.renderTable();
        },

        nextButton: () => {
          if (combatTracker.characters.length < 2) return;
          combatTracker.recordState();
          const first = combatTracker.characters.shift();
          const newFirst = combatTracker.characters.shift();
          combatTracker.characters.push(first);
          combatTracker.characters.unshift(newFirst);
          combatTracker.renderTable();
        },

        previousButton: () => {
          if (combatTracker.characters.length < 2) return;
          combatTracker.recordState();
          const last = combatTracker.characters.pop();
          combatTracker.characters.unshift(last);
          combatTracker.renderTable();
        },

        // Rendering the Table
        applyNameFilter: () => {
          const q = (combatTracker.nameFilter || "").trim().toLowerCase();
          const rows = combatTracker.tableBody.querySelectorAll("tr.main-row");
          rows.forEach((row) => {
            const idx = parseInt(row.dataset.index, 10);
            const name = ((combatTracker.characters[idx] && combatTracker.characters[idx].name) || "").toLowerCase();
            const match = !q || name.includes(q);
            row.style.display = match ? "" : "none";
            const next = row.nextElementSibling;
            if (next && next.classList.contains("details-row")) {
              next.style.display = match ? "" : "none";
            }
          });
        },

        renderTable: () => {
          combatTracker.tableBody.innerHTML = "";
          combatTracker.characters.forEach((char, index) => {
            // Preserve manual expand/collapse regardless of row position
            if (typeof char.manualOverride === "boolean") {
              char.expanded = char.manualOverride;
            } else if (typeof char.expanded !== "boolean") {
              char.expanded = false;
            }
            
            // Build critical injuries HTML
            const injuryHTML = (char.criticalInjuries && char.criticalInjuries.length)
              ? char.criticalInjuries
                  .map((injury, injIndex) => `
                    <div class="injury-tag">
                      ${injury} <button class="btn" onclick="removeCriticalInjury(${index}, ${injIndex})">‚ùå</button>
                    </div>
                  `).join("")
              : "";
            
            // Create main row
            const row = document.createElement("tr");
            row.classList.add("main-row");
            row.dataset.index = index;
            row.innerHTML = `
              <td class="initiative-cell">
                <div style="text-align: left;">
                  <span class="drag-handle" draggable="true" data-index="${index}">‚ò∞</span>
				  </div>
				  <div style="text-align: center;">
                  <input type="number" value="${char.initiative}" onchange="updateCharacter(${index}, 'initiative', this.value)" style="margin-top: 0px; width: 3rem;">
                  <button class="btn" onclick="rollInitiative(${index})">üé≤</button>
                  <div style="margin-top: 6px; font-size: 0.75rem; color: var(--yellow-color);">
                    <label>
					   
                      <input type="checkbox" ${char.hideFromPlayer ? "checked" : ""} onchange="updateCharacterCheckbox(${index}, 'hideFromPlayer', this.checked)">
						
					
					</label>
					<div>
					HIDE
					</div>
					</div>
                  </div>
                
                <button class="btn initiative-toggle-btn" onclick="toggleDetails(${index})"
                  style="clip-path: ${char.expanded ? 'polygon(50% 0%, 100% 100%, 0% 100%)' : 'polygon(0% 0%, 100% 0%, 50% 100%)'};">
                </button>
              </td>
              <td>
                ${char.artBlob
                  ? `<img class="art-thumb" src="${combatTracker.blobObjToDataUrl(char.artBlob)}" alt="Art for ${char.name || "character"}">`
                  : ``}
                <input type="text" value="${char.name}" onchange="updateCharacter(${index}, 'name', this.value)">
              </td>
              <td class="toggle-column" data-column="stat">
                <div style="display: grid; grid-template-columns: auto 1fr; align-items: center; gap: 5px;">
                  <span style="writing-mode: vertical-lr; transform: rotate(180deg); font-size: 0.7rem; color: var(--yellow-color);">MOVE</span>
                  <input type="number" value="${char.move}" onchange="updateCharacter(${index}, 'move', this.value)" style="width: 3rem;">
                  <span style="writing-mode: vertical-lr; transform: rotate(180deg); font-size: 0.7rem; color: var(--yellow-color);">BODY</span>
                  <input type="number" value="${char.body}" onchange="updateCharacter(${index}, 'body', this.value)" style="width: 3rem;">
                  <span style="writing-mode: vertical-lr; transform: rotate(180deg); font-size: 0.7rem; color: var(--yellow-color);">WILL</span>
                  <input type="number" value="${char.will || ''}" onchange="updateCharacter(${index}, 'will', this.value)" style="width: 3rem;">
                </div>
              </td>
              <td class="toggle-column" data-column="deathSave">
                <input type="number" value="${char.deathSave}" id="deathSave-${index}" onchange="updateCharacter(${index}, 'deathSave', this.value)">
                <button class="btn" onclick="incrementDeathSave(${index})">+1</button>
              </td>
              <td class="toggle-column" data-column="magazine">
                <input type="number" value="${char.magazine}" id="magazine-${index}" onchange="updateCharacter(${index}, 'magazine', this.value)">
                <div style="display: inline-flex; gap: 5px;">
                  <button class="btn" onclick="decrementMagazine(${index}, 1)">-1</button>
                  <button class="btn" onclick="decrementMagazine(${index}, 10)">-10</button>
                </div>
              </td>
              <td class="toggle-column" data-column="atk">
                <input type="number" value="${char.atk}" onchange="updateCharacter(${index}, 'atk', this.value)">
                <br>
                <button class="btn" onclick="rollAttack(${index})">Roll Attack</button>
              </td>
              <td class="toggle-column" data-column="eva">
                <input type="number" value="${char.eva}" onchange="updateCharacter(${index}, 'eva', this.value)">
                <br>
                <button class="btn" onclick="rollEvasion(${index})">Roll Evasion</button>
              </td>
              <td class="health">
                <div class="form-group">
                  <input type="number" id="currentHP-${index}" style="width: 2.5rem;" value="${char.hp}" onchange="updateCharacter(${index}, 'hp', this.value)">
                  <label for="currentHP-${index}">current_</label>
                </div>
                <div class="form-group">
                  <input type="number" id="totalHP-${index}" value="${char.total}" onchange="updateCharacter(${index}, 'total', this.value)" style="background: var(--yellow-color); width: 2.5rem; color: var(--black-color); text-align: center;">
                  <label for="totalHP-${index}">total_</label>
                </div>
                <div class="form-group">
                  <input type="number" id="headSP-${index}" value="${char.spHead}" onchange="updateCharacter(${index}, 'spHead', this.value)" style="width: 2.5rem;">
                  <label for="headSP-${index}">Head</label>
                </div>
                <br>
                <div class="form-group">
                  <input type="number" id="bodySP-${index}" value="${char.spBody}" onchange="updateCharacter(${index}, 'spBody', this.value)" style="width: 2.5rem;">
                  <label for="bodySP-${index}">Body</label>
                </div>
              </td>
              <td data-damage>
                <input type="number" value="" id="damage-${index}" style="width: 4rem; margin-bottom: 5px;">
                <br>
                <button class="btn apply-btn" onclick="confirmDamage(${index}, 'full')">Full</button>
                <button class="btn apply-btn" onclick="confirmDamage(${index}, 'half')">HALF</button>
                <button class="btn apply-btn" onclick="confirmDamage(${index}, 'ignore')">Ignore</button>
              </td>
              <td class="toggle-column" data-column="effects">
                <div style="display: grid; grid-template-columns: repeat(1, 3fr); gap: 2px;">
                  <div>
                    <label style="display: block; font-size: 0.7rem; color: var(--yellow-color);">Headshot</label>
                    <input type="checkbox" ${char.headshot ? "checked" : ""} onchange="updateCharacterCheckbox(${index}, 'headshot', this.checked)">
                  </div>
                  <div>
                    <label style="display: block; font-size: 0.7rem; color: var(--yellow-color);">Critical</label>
                    <input type="checkbox" ${char.critical ? "checked" : ""} onchange="updateCharacterCheckbox(${index}, 'critical', this.checked)">
                  </div>
                  <div>
                    <label style="display: block; font-size: 0.7rem; color: var(--yellow-color);">AP</label>
                    <input type="checkbox" ${char.armorPiercing ? "checked" : ""} onchange="updateCharacterCheckbox(${index}, 'armorPiercing', this.checked)">
                  </div>
                </div>
              </td>
              <td class="toggle-column" data-column="notes">
                <textarea rows="3" cols="20" onchange="updateCharacter(${index}, 'notes', this.value)">${char.notes || ""}</textarea>
              </td>
              <td>
                <div class="injury-display" id="criticalDisplay-${index}">
                  ${injuryHTML}
                </div>
                <div class="injury-add">
                  <select id="criticalSelect-${index}">
                    <optgroup label="Body">
                      <option value="Dismembered Arm">Dismembered Arm</option>
                      <option value="Dismembered Hand">Dismembered Hand</option>
                      <option value="Collapsed Lung">Collapsed Lung</option>
                      <option value="Broken Ribs">Broken Ribs</option>
                      <option value="Broken Arm">Broken Arm</option>
                      <option value="Foreign Object">Foreign Object</option>
                      <option value="Broken Leg">Broken Leg</option>
                      <option value="Torn Muscle">Torn Muscle</option>
                      <option value="Spinal Injury">Spinal Injury</option>
                      <option value="Crushed Fingers">Crushed Fingers</option>
                      <option value="Dismembered Leg">Dismembered Leg</option>
                    </optgroup>
                    <optgroup label="Head">
                      <option value="Lost Eye">Lost Eye</option>
                      <option value="Brain Injury">Brain Injury</option>
                      <option value="Damaged Eye">Damaged Eye</option>
                      <option value="Concussion">Concussion</option>
                      <option value="Broken Jaw">Broken Jaw</option>
                      <option value="Whiplash">Whiplash</option>
                      <option value="Cracked Skull">Cracked Skull</option>
                      <option value="Damaged Ear">Damaged Ear</option>
                      <option value="Crushed Windpipe">Crushed Windpipe</option>
                      <option value="Lost Ear">Lost Ear</option>
                    </optgroup>
                  </select>
                  <button class="btn" onclick="addCriticalInjury(${index})">Add Injury</button>
                </div>
              </td>
              <td>
                <button class="btn action-button" onclick="copyCharacter(${index})">CLONE</button>
                <button class="btn action-button" onclick="saveCharacter(${index})">SAVE</button>
                <button class="btn action-button" onclick="loadCharacter()">LOAD</button>
                <button class="btn action-button" onclick="deleteCharacter(${index})">DELETE</button>
              </td>
            `;
            combatTracker.tableBody.appendChild(row);
            
            // Create details row (expanded view)
            const detailsRow = document.createElement("tr");
            detailsRow.classList.add("detail-row");
            detailsRow.dataset.index = index;
            detailsRow.style.display = char.expanded ? "table-row" : "none";
            const detailsCell = document.createElement("td");
            detailsCell.colSpan = "13";
            detailsCell.innerHTML = `
              <div style="padding: 10px; background: #222; text-align: left;">
                <div class="art-box">
                  <div>
                    <div class="art-preview-container">
                      <div class="art-preview" id="artPreview-${index}" contenteditable="true" spellcheck="false" onpaste="handleArtPaste(event, ${index})" aria-label="Character art">
                        ${char.artBlob ? `<img src="${combatTracker.blobObjToDataUrl(char.artBlob)}" alt="Art for ${char.name || "character"}">` : `<div class="art-empty">No art set</div>`}
                      </div>
                    </div>
                    <div style="margin-top: 6px;">
                      <button class="btn" onclick="triggerArtUpload(event, ${index})">Upload</button>
                    </div>
                    <input type="file" id="artFile-${index}" accept="image/*" style="display: none;" onchange="handleArtFile(event, ${index})">
                  </div>
                  <div style="flex: 1; min-width: 240px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 0.9rem; color: var(--yellow-color);">Additional details</label>
                    <textarea
                      rows="10"
                      style="width: 100%; box-sizing: border-box; background: #111; color: var(--blue-color); border: 1px solid rgba(84, 193, 230, 0.5);"
                      placeholder="Add extra context, gear notes, conditions, or reminders..."
                      onchange="updateCharacter(${index}, 'details', this.value)"
                    >${char.details || ""}</textarea>
                  </div>
                </div>
              </div>
            `;
            detailsRow.appendChild(detailsCell);
            combatTracker.tableBody.appendChild(detailsRow);
          });
          combatTracker.applyColumnVisibility();
          combatTracker.setupDragAndDrop();

          // GM sends updates to player window
          if (!isPlayerView && playerWindow && !playerWindow.closed) {
            try {
              playerWindow.postMessage(
                {
                  type: "trackerUpdate",
                  characters: combatTracker.characters
                },
                "*"
              );
            } catch (e) {
              console.error("Failed to postMessage to player window", e);
            }
          }

          // Re-apply name filter after re-rendering
          if (combatTracker.nameFilter && combatTracker.nameFilter.trim()) {
            combatTracker.applyNameFilter();
          }
          combatTracker.saveSession();
        },

        // Placeholder for column visibility toggling
        applyColumnVisibility: () => {
          // Future implementation for toggling columns based on user preferences
        },

        // Drag-and-drop row reordering
        setupDragAndDrop: () => {
          const handles = document.querySelectorAll(".drag-handle");
          const tbody = combatTracker.tableBody;
          const getMainRows = () => Array.from(document.querySelectorAll("tr.main-row"));

          const placeDropIndicator = (insertIndex) => {
            const mainRows = getMainRows();
            dropInsertIndex = insertIndex;
            if (!dropIndicator) {
              dropIndicator = document.createElement("tr");
              const td = document.createElement("td");
              td.colSpan = "13";
              td.style.padding = "0";
              const bar = document.createElement("div");
              bar.className = "drop-indicator";
              td.appendChild(bar);
              dropIndicator.appendChild(td);
            }
            if (dropIndicator.parentNode) {
              dropIndicator.parentNode.removeChild(dropIndicator);
            }
            const targetMain = mainRows[insertIndex];
            if (targetMain) {
              tbody.insertBefore(dropIndicator, targetMain);
            } else if (mainRows.length) {
              const lastMain = mainRows[mainRows.length - 1];
              const afterNode = lastMain.nextSibling && !lastMain.nextSibling.classList.contains("main-row")
                ? lastMain.nextSibling
                : lastMain;
              tbody.insertBefore(dropIndicator, afterNode.nextSibling);
            }
          };

          const removeDropIndicator = () => {
            if (dropIndicator && dropIndicator.parentNode) {
              dropIndicator.parentNode.removeChild(dropIndicator);
            }
            dropInsertIndex = null;
          };

          const autoScroll = (clientY) => {
            const margin = 40;
            const speed = 10;
            if (clientY < margin) {
              window.scrollBy(0, -speed);
            } else if (window.innerHeight - clientY < margin) {
              window.scrollBy(0, speed);
            }
          };

          const performDrop = (insertIndex) => {
            if (dragSourceIndex === null || insertIndex === null) return;
            removeDropIndicator();
            const source = dragSourceIndex;
            let target = insertIndex;
            if (target > source) target -= 1;
            if (target === source) return;
            combatTracker.recordState();
            const [moved] = combatTracker.characters.splice(source, 1);
            combatTracker.characters.splice(target, 0, moved);
            dragSourceIndex = null;
            combatTracker.renderTable();
          };

          handles.forEach((handle) => {
            handle.addEventListener("dragstart", (event) => {
              dragSourceIndex = parseInt(handle.dataset.index, 10);
              event.dataTransfer?.setData("text/plain", "");
              event.dataTransfer?.setDragImage?.(document.createElement("div"), 0, 0);
            });
            handle.addEventListener("dragend", () => {
              dragSourceIndex = null;
              removeDropIndicator();
            });
          });

          const rowDragOver = (event, row) => {
            event.preventDefault();
            event.stopPropagation();
            const rect = row.getBoundingClientRect();
            const before = event.clientY < rect.top + rect.height / 2;
            const targetIndex = parseInt(row.dataset.index, 10);
            const insertIndex = before ? targetIndex : targetIndex + 1;
            placeDropIndicator(insertIndex);
            autoScroll(event.clientY);
          };

          const mainRows = getMainRows();
          mainRows.forEach((row) => {
            row.addEventListener("dragover", (event) => rowDragOver(event, row));
            row.addEventListener("drop", (event) => {
              event.preventDefault();
              event.stopPropagation();
              const rect = row.getBoundingClientRect();
              const before = event.clientY < rect.top + rect.height / 2;
              const targetIndex = parseInt(row.dataset.index, 10);
              const insertIndex = before ? targetIndex : targetIndex + 1;
              performDrop(insertIndex);
            });
          });

          if (!tbody.dataset.dragHandlersAttached) {
            tbody.addEventListener("dragover", (event) => {
              const targetMain = event.target.closest && event.target.closest("tr.main-row");
              if (targetMain) return;
              const targetDetail = event.target.closest && event.target.closest("tr.detail-row");
              if (targetDetail) {
                event.preventDefault();
                const idx = parseInt(targetDetail.dataset.index, 10);
                const rect = targetDetail.getBoundingClientRect();
                const before = event.clientY < rect.top + rect.height / 2;
                const insertIndex = before ? idx : idx + 1;
                placeDropIndicator(insertIndex);
                autoScroll(event.clientY);
                return;
              }
              event.preventDefault();
              const lastIndex = getMainRows().length;
              placeDropIndicator(lastIndex);
              autoScroll(event.clientY);
            });

            tbody.addEventListener("drop", (event) => {
              const targetMain = event.target.closest && event.target.closest("tr.main-row");
              if (targetMain) return;
              const targetDetail = event.target.closest && event.target.closest("tr.detail-row");
              if (targetDetail) {
                event.preventDefault();
                const idx = parseInt(targetDetail.dataset.index, 10);
                const rect = targetDetail.getBoundingClientRect();
                const before = event.clientY < rect.top + rect.height / 2;
                const insertIndex = before ? idx : idx + 1;
                performDrop(insertIndex);
                return;
              }
              event.preventDefault();
              const lastIndex = getMainRows().length;
              const insertIndex = dropInsertIndex !== null ? dropInsertIndex : lastIndex;
              performDrop(insertIndex);
            });
            tbody.dataset.dragHandlersAttached = "true";
          }
        },

        // Bind all event listeners
        bindEventListeners: () => {
          document.getElementById("undoButton").addEventListener("click", combatTracker.undo);
          document.getElementById("redoButton").addEventListener("click", combatTracker.redo);
          document.getElementById("sortFixedButton").addEventListener("click", combatTracker.sortWithRow1Fixed);
          document.getElementById("topButton").addEventListener("click", combatTracker.topButton);
          document.getElementById("nextButton").addEventListener("click", combatTracker.nextButton);
          document.getElementById("previousButton").addEventListener("click", combatTracker.previousButton);

          const mainNameFilterEl = document.getElementById("mainNameFilter");
          if (mainNameFilterEl) {
            mainNameFilterEl.addEventListener("input", () => {
              combatTracker.nameFilter = mainNameFilterEl.value;
              combatTracker.applyNameFilter();
            });
            mainNameFilterEl.addEventListener("keydown", (e) => {
              if (e.key === "Escape") {
                mainNameFilterEl.value = "";
                combatTracker.nameFilter = "";
                combatTracker.applyNameFilter();
              }
            });
          }

          document.getElementById("addCharacter").addEventListener("click", combatTracker.addCharacter);
          document.getElementById("newSession").addEventListener("click", combatTracker.newSession);

          if (!isPlayerView) {
            const playerBtn = document.getElementById("playerViewButton");
            playerBtn.addEventListener("click", () => {
              const url = new URL(window.location.href);
              url.searchParams.set("view", "player");
              if (!playerWindow || playerWindow.closed) {
                playerWindow = window.open(
                  url.toString(),
                  "PlayerView",
                  "width=800,height=600"
                );
              } else {
                playerWindow.focus();
              }
            });
          }

          document.getElementById("exportData").addEventListener("click", () => {
            const dataStr = JSON.stringify(combatTracker.characters, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "combat_tracker_data.json";
            a.click();
            URL.revokeObjectURL(url);
          });
          document.getElementById("importData").addEventListener("click", () => {
            document.getElementById("fileInput").click();
          });
          document.getElementById("fileInput").addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const importedData = JSON.parse(e.target.result);
                  if (Array.isArray(importedData)) {
                    combatTracker.recordState();
                    combatTracker.characters = importedData;
                    combatTracker.normalizeCharacters();
                    combatTracker.renderTable();
                  } else {
                    alert("Invalid file format.");
                  }
                } catch (error) {
                  alert("Error reading file: " + error.message);
                }
              };
              reader.readAsText(file);
            }
          });
          document.getElementById("helpButton").addEventListener("click", () => {
            document.getElementById("helpPopup").style.display = "flex";
          });
          document.querySelector(".close-popup")?.addEventListener("click", () => {
            document.getElementById("helpPopup").style.display = "none";
          });
          // Focus main filter with / (when not typing in an input)
          document.addEventListener("keydown", (e) => {
            if (e.defaultPrevented) return;
            if (e.metaKey || e.ctrlKey || e.altKey) return;
            const targetTag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
            const isTypingField = targetTag === "input" || targetTag === "textarea" || (e.target && e.target.isContentEditable);
            if (isTypingField) return;
            const isSlash = e.key === "/" || e.code === "Slash";
            if (!isSlash) return;
            // If damage queue modal is open, prefer its filter
            const dmgQueue = document.getElementById("damageQueuePopup");
            const dmgQueueFilter = document.getElementById("damageQueueFilter");
            if (dmgQueue && dmgQueue.style.display === "flex" && dmgQueueFilter) {
              e.preventDefault();
              dmgQueueFilter.focus();
              dmgQueueFilter.select?.();
              return;
            }
            const main = document.getElementById("mainNameFilter");
            if (!main) return;
            e.preventDefault();
            main.focus();
            main.select?.();
          });

          window.addEventListener("click", (event) => {
            if (event.target === document.getElementById("helpPopup")) {
              document.getElementById("helpPopup").style.display = "none";
            }
          });
          const sessionToggle = document.getElementById("sessionToggle");
          const sessionDropdown = document.getElementById("sessionDropdown");
          sessionToggle.addEventListener("click", () => {
            sessionDropdown.classList.toggle("open");
          });
          // Focus main filter with / (when not typing in an input)
          document.addEventListener("keydown", (e) => {
            if (e.defaultPrevented) return;
            if (e.metaKey || e.ctrlKey || e.altKey) return;
            const targetTag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
            const isTypingField = targetTag === "input" || targetTag === "textarea" || (e.target && e.target.isContentEditable);
            if (isTypingField) return;
            const isSlash = e.key === "/" || e.code === "Slash";
            if (!isSlash) return;
            // If damage queue modal is open, prefer its filter
            const dmgQueue = document.getElementById("damageQueuePopup");
            const dmgQueueFilter = document.getElementById("damageQueueFilter");
            if (dmgQueue && dmgQueue.style.display === "flex" && dmgQueueFilter) {
              e.preventDefault();
              dmgQueueFilter.focus();
              dmgQueueFilter.select?.();
              return;
            }
            const main = document.getElementById("mainNameFilter");
            if (!main) return;
            e.preventDefault();
            main.focus();
            main.select?.();
          });

          window.addEventListener("click", (event) => {
            if (!sessionDropdown.contains(event.target) && !sessionToggle.contains(event.target)) {
              sessionDropdown.classList.remove("open");
            }
          });
          document.addEventListener("keydown", (event) => {
            if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "z") {
              if (event.shiftKey) {
                event.preventDefault();
                combatTracker.redo();
              } else {
                event.preventDefault();
                combatTracker.undo();
              }
            }
          });

          // Damage modals
          document.getElementById("openDamageModalBtn")?.addEventListener("click", openDamageQueueModal);

          document.getElementById("closeDamageQueue")?.addEventListener("click", closeDamageQueueModal);
          document.getElementById("damageQueueCloseBtn")?.addEventListener("click", closeDamageQueueModal);
          document.getElementById("damageQueueFilter")?.addEventListener("input", renderDamageQueueList);

          document.getElementById("closeDamageApply")?.addEventListener("click", closeDamageApplyModal);

          // Click outside to close
          document.getElementById("damageQueuePopup")?.addEventListener("click", (event) => {
            if (event.target === document.getElementById("damageQueuePopup")) closeDamageQueueModal();
          });
          document.getElementById("damageApplyPopup")?.addEventListener("click", (event) => {
            if (event.target === document.getElementById("damageApplyPopup")) closeDamageApplyModal();
          });

          // Keyboard support: '/' refocuses filter, ESC closes modals
          document.addEventListener("keydown", (event) => {
            const queueOpen = isVisibleFlex(document.getElementById("damageQueuePopup"));
            const applyOpen = isVisibleFlex(document.getElementById("damageApplyPopup"));

            const activeEl = document.activeElement;
            const isTyping = activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA" || activeEl.isContentEditable);

            if ((event.key === "/" || event.code === "Slash") && !isTyping) {
              if (queueOpen) {
                event.preventDefault();
                const f = document.getElementById("damageQueueFilter");
                if (f) {
                  f.focus();
                  if (typeof f.select === "function") f.select();
                }
                return;
              }

              // Main window: focus the name filter
              event.preventDefault();
              const mf = document.getElementById("mainNameFilter");
              if (mf) {
                mf.focus();
                if (typeof mf.select === "function") mf.select();
              }
              return;
            }

            if (event.key === "Escape") {
              if (applyOpen) closeDamageApplyModal();
              if (queueOpen) closeDamageQueueModal();
            }
          });

        },

        init: () => {
          if (isPlayerView) {
            // Player (screenshare) view
            setupPlayerView();

            // Initial render from localStorage as fallback (if GM not yet posting)
            try {
              const sessionData = localStorage.getItem("combatTrackerSession");
              if (sessionData) {
                const chars = JSON.parse(sessionData);
                renderPlayerView(chars);
              }
            } catch (e) {
              console.error("Failed to load initial session for player view", e);
            }

            // Listen for live updates from GM window
            window.addEventListener("message", (event) => {
              if (!event.data || event.data.type !== "trackerUpdate") return;
              renderPlayerView(event.data.characters);
            });
          } else {
            // GM (full control) view
            combatTracker.bindEventListeners();
            combatTracker.loadSession();
          }
        }
      };

      let playerWindow = null;
      let dragSourceIndex = null;
      let dropIndicator = null;
      let dropInsertIndex = null;

      // Damage modal state + helpers
      let damageSelectedIndex = null;
      let damageAutoCloseTimer = null;

      const isVisibleFlex = (el) => !!el && (el.style.display === "flex" || el.style.display === "block");

      const showPopup = (id) => {
        const el = document.getElementById(id);
        if (el) el.style.display = "flex";
      };

      const hidePopup = (id) => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
      };

      const getSortedQueueTargets = () => {
        return (combatTracker.characters || [])
          .map((c, i) => ({
            index: i,
            name: (c.name || "").trim(),
            artBlob: c.artBlob || null
          }))
          .filter((x) => x.name.length > 0)
          .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: "base" }));
      };

      function renderDamageQueueList() {
        const list = document.getElementById("damageQueueList");
        const filterInput = document.getElementById("damageQueueFilter");
        if (!list || !filterInput) return;

        const needle = (filterInput.value || "").trim().toLowerCase();
        const targets = getSortedQueueTargets().filter((t) => t.name.toLowerCase().includes(needle));

        list.innerHTML = targets.length
          ? ""
          : `<li style="opacity:0.85; padding:6px 2px;">No matching names.</li>`;

        targets.forEach((t) => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "damage-list-btn";
          const portraitHtml = t.artBlob
            ? `<img class="damage-portrait" src="${combatTracker.blobObjToDataUrl(t.artBlob)}" alt="">`
            : `<div class="damage-portrait--placeholder"></div>`;
          btn.innerHTML = `${portraitHtml}<span>${t.name}</span>`;
          btn.addEventListener("click", () => {
            hidePopup("damageQueuePopup");
            openDamageApplyModal(t.index);
          });
          li.appendChild(btn);
          list.appendChild(li);
        });
      };

      function openDamageQueueModal() {
        // Always available in GM view; in player view, do nothing.
        if (isPlayerView) return;

        const popup = document.getElementById("damageQueuePopup");
        if (!popup) return;

        // Bring above any other popup (e.g., Help).
        popup.style.display = "flex";

        const filter = document.getElementById("damageQueueFilter");
        if (filter) {
          filter.value = "";
          renderDamageQueueList();
          // Focus after paint
          setTimeout(() => filter.focus(), 0);
        }
      };

      function closeDamageQueueModal() {
        hidePopup("damageQueuePopup");
      };

      const addCriticalInjuryDirect = (index, injury) => {
        if (!injury) return;
        combatTracker.recordState();
        if (!combatTracker.characters[index].criticalInjuries) {
          combatTracker.characters[index].criticalInjuries = [];
        }
        combatTracker.characters[index].criticalInjuries.push(injury);
        combatTracker.renderTable();
      };

      const removeCriticalInjuryDirect = (index, injuryIndex) => {
        combatTracker.recordState();
        combatTracker.characters[index].criticalInjuries.splice(injuryIndex, 1);
        combatTracker.renderTable();
      };

      const renderDamageApplyModal = (index, reviewText = "") => {
        const content = document.getElementById("damageApplyContent");
        const review = document.getElementById("damageApplyReview");
        if (!content) return;

        const char = combatTracker.characters[index];
        if (!char) return;

        const name = (char.name || "").trim() || "Unnamed";
        const portrait = char.artBlob
          ? `<img class="damage-portrait" src="${combatTracker.blobObjToDataUrl(char.artBlob)}" alt="">`
          : `<div class="damage-portrait--placeholder"></div>`;

        const injuryTags = (char.criticalInjuries || []).map((inj, injIndex) => {
          return `<span class="injury-tag" style="margin-bottom:6px;">
                    ${inj}
                    <button type="button" class="btn btn--secondary" data-remove-injury="${injIndex}" style="font-size:0.65rem; padding:2px 6px; margin-left:6px;">X</button>
                  </span>`;
        }).join("");

        content.innerHTML = `
          <div class="damage-apply-title">
            ${portrait}
            <h2 style="margin:0;">${name}</h2>
          </div>

          <div class="damage-mini-grid">
            <div class="damage-mini-card">
              <h3>HP</h3>
              <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
                <div class="form-group">
                  <input type="number" id="modalCurrentHp" style="width: 4.5rem;" value="${char.hp}">
                  <label for="modalCurrentHp">current_</label>
                </div>
                <div class="form-group">
                  <input type="number" id="modalTotalHp" style="width: 4.5rem; background: var(--yellow-color); color: var(--black-color);" value="${char.total}" disabled>
                  <label for="modalTotalHp">total_</label>
                </div>
                <div class="form-group">
                  <input type="number" id="modalHeadSp" style="width: 4.5rem;" value="${char.spHead}">
                  <label for="modalHeadSp">Head SP</label>
                </div>
                <div class="form-group">
                  <input type="number" id="modalBodySp" style="width: 4.5rem;" value="${char.spBody}">
                  <label for="modalBodySp">Body SP</label>
                </div>
              </div>
            </div>

            <div class="damage-mini-card">
              <h3>DAMAGE</h3>
              <input type="number" id="modalDamageValue" value="" style="width: 6rem; margin-bottom: 8px;">
              <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <button type="button" class="btn apply-btn" id="modalDamageFull">FULL</button>
                <button type="button" class="btn apply-btn" id="modalDamageHalf">HALF</button>
                <button type="button" class="btn apply-btn" id="modalDamageIgnore">IGNORE</button>
              </div>
            </div>

            <div class="damage-mini-card">
              <h3>EFFECTS</h3>
              <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <label style="display:flex; flex-direction:column; gap:4px; font-size:0.85rem;">
                  <span style="color:var(--yellow-color);">Headshot</span>
                  <input type="checkbox" id="modalHeadshot" ${char.headshot ? "checked" : ""}>
                </label>
                <label style="display:flex; flex-direction:column; gap:4px; font-size:0.85rem;">
                  <span style="color:var(--yellow-color);">Critical</span>
                  <input type="checkbox" id="modalCritical" ${char.critical ? "checked" : ""}>
                </label>
                <label style="display:flex; flex-direction:column; gap:4px; font-size:0.85rem;">
                  <span style="color:var(--yellow-color);">AP</span>
                  <input type="checkbox" id="modalAP" ${char.armorPiercing ? "checked" : ""}>
                </label>
              </div>
            </div>

            <div class="damage-mini-card">
              <h3>CRITICAL INJURY</h3>
              <div id="modalInjuryTags" style="margin-bottom: 8px; display:flex; flex-wrap:wrap; gap:6px;">
                ${injuryTags || `<span style="opacity:0.85;">None</span>`}
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                <select id="modalCriticalSelect">
                  <optgroup label="Body">
                    <option value="Dismembered Arm">Dismembered Arm</option>
                    <option value="Dismembered Hand">Dismembered Hand</option>
                    <option value="Collapsed Lung">Collapsed Lung</option>
                    <option value="Broken Ribs">Broken Ribs</option>
                    <option value="Broken Arm">Broken Arm</option>
                    <option value="Foreign Object">Foreign Object</option>
                    <option value="Broken Leg">Broken Leg</option>
                    <option value="Torn Muscle">Torn Muscle</option>
                    <option value="Spinal Injury">Spinal Injury</option>
                    <option value="Crushed Fingers">Crushed Fingers</option>
                    <option value="Dismembered Leg">Dismembered Leg</option>
                  </optgroup>
                  <optgroup label="Head">
                    <option value="Lost Eye">Lost Eye</option>
                    <option value="Brain Injury">Brain Injury</option>
                    <option value="Damaged Eye">Damaged Eye</option>
                    <option value="Concussion">Concussion</option>
                    <option value="Broken Jaw">Broken Jaw</option>
                    <option value="Whiplash">Whiplash</option>
                    <option value="Cracked Skull">Cracked Skull</option>
                    <option value="Damaged Ear">Damaged Ear</option>
                    <option value="Crushed Windpipe">Crushed Windpipe</option>
                    <option value="Lost Ear">Lost Ear</option>
                  </optgroup>
                </select>
                <button type="button" class="btn" id="modalAddInjury">Add Injury</button>
              </div>
            </div>
          </div>
        `;

        if (review) {
          if (reviewText) {
            review.style.display = "block";
            review.textContent = reviewText;
          } else {
            review.style.display = "none";
            review.textContent = "";
          }
        }

        // Wire handlers
        const hpInput = document.getElementById("modalCurrentHp");
        const headSpInput = document.getElementById("modalHeadSp");
        const bodySpInput = document.getElementById("modalBodySp");

        hpInput?.addEventListener("change", () => combatTracker.updateCharacter(index, "hp", hpInput.value));
        headSpInput?.addEventListener("change", () => combatTracker.updateCharacter(index, "spHead", headSpInput.value));
        bodySpInput?.addEventListener("change", () => combatTracker.updateCharacter(index, "spBody", bodySpInput.value));

        const headshotCb = document.getElementById("modalHeadshot");
        const criticalCb = document.getElementById("modalCritical");
        const apCb = document.getElementById("modalAP");

        headshotCb?.addEventListener("change", () => combatTracker.updateCharacterCheckbox(index, "headshot", headshotCb.checked));
        criticalCb?.addEventListener("change", () => combatTracker.updateCharacterCheckbox(index, "critical", criticalCb.checked));
        apCb?.addEventListener("change", () => combatTracker.updateCharacterCheckbox(index, "armorPiercing", apCb.checked));

        const addInjuryBtn = document.getElementById("modalAddInjury");
        const selectInjury = document.getElementById("modalCriticalSelect");
        addInjuryBtn?.addEventListener("click", () => {
          addCriticalInjuryDirect(index, selectInjury?.value);
          renderDamageApplyModal(index);
        });

        document.querySelectorAll("[data-remove-injury]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const injIndex = parseInt(btn.getAttribute("data-remove-injury"), 10);
            removeCriticalInjuryDirect(index, injIndex);
            renderDamageApplyModal(index);
          });
        });

        const dmgInput = document.getElementById("modalDamageValue");
        const doApply = (mode) => {
          const raw = parseInt(dmgInput?.value, 10) || 0;
          if (!raw) return;

          combatTracker.recordState();

          const beforeHp = parseInt(char.hp) || 0;
          const beforeHeadSp = parseInt(char.spHead) || 0;
          const beforeBodySp = parseInt(char.spBody) || 0;

          let sp = char.spBody;
          const { headshot, critical, armorPiercing } = char;
          if (headshot) sp = char.spHead;

          const spNum = parseInt(sp) || 0;
          const spEffective = mode === "ignore" ? 0 : (mode === "half" ? Math.ceil(spNum / 2) : spNum);
          const penetration = raw > spEffective;
          const remainingDamage = penetration ? (raw - spEffective) : 0;

          if (mode !== "ignore" && penetration) {
            const ablateValue = armorPiercing ? 2 : 1;
            if (headshot) {
              char.spHead = Math.max(0, spNum - ablateValue);
            } else {
              char.spBody = Math.max(0, spNum - ablateValue);
            }
          }

          const hpNum = parseInt(char.hp) || 0;
          const hpAfterBase = hpNum - (headshot ? remainingDamage * 2 : remainingDamage) - (critical ? 5 : 0);
          char.hp = hpAfterBase;

          dmgInput.value = "";
          combatTracker.renderTable();

          const afterHp = parseInt(char.hp) || 0;
          const afterHeadSp = parseInt(char.spHead) || 0;
          const afterBodySp = parseInt(char.spBody) || 0;

          const modeLabel = mode.toUpperCase();
          const reviewText = `Applied ${raw} (${modeLabel}). HP ${beforeHp} ‚Üí ${afterHp}. Head SP ${beforeHeadSp} ‚Üí ${afterHeadSp}. Body SP ${beforeBodySp} ‚Üí ${afterBodySp}.`;

          renderDamageApplyModal(index, reviewText);

          if (damageAutoCloseTimer) clearTimeout(damageAutoCloseTimer);
          damageAutoCloseTimer = setTimeout(() => {
            closeDamageApplyModal();
          }, 2000);
        };

        document.getElementById("modalDamageFull")?.addEventListener("click", () => doApply("full"));
        document.getElementById("modalDamageHalf")?.addEventListener("click", () => doApply("half"));
        document.getElementById("modalDamageIgnore")?.addEventListener("click", () => doApply("ignore"));

        // Default focus: damage value input
        setTimeout(() => dmgInput?.focus(), 0);
      };

      function openDamageApplyModal(index) {
        if (isPlayerView) return;
        damageSelectedIndex = index;
        showPopup("damageApplyPopup");
        renderDamageApplyModal(index);
      };

      function closeDamageApplyModal() {
        if (damageAutoCloseTimer) clearTimeout(damageAutoCloseTimer);
        damageAutoCloseTimer = null;
        hidePopup("damageApplyPopup");
        damageSelectedIndex = null;
      };


      function setupPlayerView() {
        // Replace the body with a stripped-down initiative display
        document.body.innerHTML = `
          <h1>Turn Order</h1>
          <div id="playerList"></div>
        `;
      }

      function renderPlayerView(characters) {
        const container = document.getElementById("playerList");
        if (!container) return;

        // Use the order received from GM as-is
        const chars = characters || [];
        const visibleChars = chars.filter((c) => !c.hideFromPlayer);

        const html = visibleChars.map((c) => {
          const art = c.artBlob
            ? `data:${c.artBlob.type || "image/png"};base64,${c.artBlob.data}`
            : null;
          const artHtml = art
            ? `<img src="${art}" alt="" style="width:64px;height:64px;object-fit:cover;border:1px solid #444;">`
            : `<div style="width:64px;height:64px;"></div>`;

          return `
            <div class="char-row" style="
              display:grid;
              grid-template-columns: 72px 1fr auto;
              align-items:center;
              gap:16px;
              padding:8px 10px;
              border-bottom:1px solid #333;
            ">
              ${artHtml}
              <div class="name" style="font-size:1.2rem;">
                ${c.name || "Unnamed"}
              </div>
              <div class="initiative" style="margin-left:auto;font-size:1.1rem;">
                ${c.initiative || ""}
              </div>
            </div>
          `;
        }).join("");

        container.innerHTML = html;
      }

      // Initialize on DOM ready
      document.addEventListener("DOMContentLoaded", combatTracker.init);


      // Ensure the Apply Damage button is always wired, even if other bindings are skipped.
      window.openDamageQueueModal = openDamageQueueModal;
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("openDamageModalBtn");
        if (btn) {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            openDamageQueueModal();
          });
        }
      });

      // Expose functions for inline event handlers
      window.updateCharacter = combatTracker.updateCharacter;
      window.updateCharacterCheckbox = combatTracker.updateCharacterCheckbox;
      window.rollInitiative = combatTracker.rollInitiative;
      window.confirmDamage = combatTracker.confirmDamage;
      window.incrementDeathSave = combatTracker.incrementDeathSave;
      window.decrementMagazine = combatTracker.decrementMagazine;
      window.deleteCharacter = combatTracker.deleteCharacter;
      window.addCriticalInjury = combatTracker.addCriticalInjury;
      window.removeCriticalInjury = combatTracker.removeCriticalInjury;
      window.copyCharacter = combatTracker.copyCharacter;
      window.saveCharacter = combatTracker.saveCharacter;
      window.loadCharacter = combatTracker.loadCharacter;
      window.rollAttack = combatTracker.rollAttack;
      window.rollEvasion = combatTracker.rollEvasion;
      window.handleArtFile = combatTracker.handleArtFile;
      window.handleArtPaste = combatTracker.handleArtPaste;
      window.pasteArtFromClipboard = combatTracker.pasteArtFromClipboard;
      window.triggerArtUpload = combatTracker.triggerArtUpload;
      window.copyTextToClipboard = combatTracker.copyTextToClipboard;
      window.fallbackCopyTextToClipboard = combatTracker.fallbackCopyTextToClipboard;
      window.toggleDetails = combatTracker.toggleDetails;
      window.sortWithRow1Fixed = combatTracker.sortWithRow1Fixed;
      window.topButton = combatTracker.topButton;
      window.nextButton = combatTracker.nextButton;
      window.previousButton = combatTracker.previousButton;
    })();
  </script>
</body>
</html>
